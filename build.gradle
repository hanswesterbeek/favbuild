buildscript {
	ext {
		springBootVersion = '1.5.8.RELEASE'
	}
	repositories {
		mavenCentral()
		jcenter()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
		classpath 'com.bmuschko:gradle-docker-plugin:3.0.12'
		classpath "com.avast.gradle:docker-compose-gradle-plugin:0.4.5"
	}
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'org.springframework.boot'
apply plugin: 'com.bmuschko.docker-remote-api'
apply plugin: 'docker-compose'

import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

import java.time.Duration

group = 'nl.enhance'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = 1.8

repositories {
	mavenCentral()
}

task wrapper(type: Wrapper) {
    gradleVersion = '4.3'
}

dependencies {
	compile('org.springframework.boot:spring-boot-starter-data-jpa')
	compile('org.springframework.boot:spring-boot-starter-web')
	compile('org.springframework.boot:spring-boot-starter-actuator')
	runtime('org.postgresql:postgresql')
	testCompile('org.springframework.boot:spring-boot-starter-test')
}

task copyJar(type: Copy) {
	dependsOn(bootRepackage)
	def fileName = "$project.name-${project.version}.jar"

	from "$buildDir/libs/${fileName}"
	into "$buildDir/docker/"
	include(fileName)
	rename (fileName, 'favbuild.jar')

}

task createDockerfile(type: Dockerfile) {

	instructionsFromTemplate(new File(project.buildDir.getParent() + "/Dockerfile"))
}

task buildImage(type: DockerBuildImage) {

	inputDir = createDockerfile.destFile.parentFile
	tag = "favbuild:${project.version}".toString()
}

buildImage.dependsOn(copyJar, createDockerfile)
build.dependsOn(buildImage)

dockerCompose {

	buildBeforeUp = false // everything was already built

	// by default we wait no longer than 300 seconds for everything to become healthy
	waitForHealthyStateTimeout = project.hasProperty("startTimeOutSeconds")?
			Duration.ofSeconds(Long.parseLong(project.getProperty('startTimeOutSeconds'))): Duration.ofSeconds(30)

	projectName = "e2etests_${project.version}"
	captureContainersOutput = project.hasProperty('containerLogEnabled')
	// kill swiftly when we're done
	dockerComposeStopTimeout = Duration.ofSeconds(1)

	executable = project.hasProperty('dockerComposePath') ?
			project.getProperty('dockerComposePath'): '/usr/local/bin/docker-compose'

	dockerExecutable = project.hasProperty('dockerPath') ?
			project.getProperty('dockerPath') : '/usr/local/bin/docker'

	// defaults for these values are in ./env so that docker-compose can access them easily
	environment.put('TAG', project.version)

	if (project.hasProperty("debugMode")) {
		stopContainers = false
		removeContainers = false
	}

	if (project.hasProperty('keepContainers')) {
		// not removing the containers can be useful so that we may inspect their logs using 'docker logs'.
		removeContainers = false
	}
	removeVolumes = true
}

test {
	include '**/*Test.*'
	exclude '**/*IntegrationTest.*'
	exclude '**/*FunctionalTest.*'
	testLogging {
		showStandardStreams = project.hasProperty("showTestLogging")
	}
}

task integrationTest(type: Test, dependsOn: testClasses)  {
	include '**/*IntegrationTest.*'
}

task functionalTest(type: Test, dependsOn: testClasses)  {
	include '**/*FunctionalTest.*'

	doFirst {
		def dockerRuntimeInfo = dockerCompose.servicesInfos
		def envProperties = [:]
		envProperties['app.url'] = "http://localhost:${dockerRuntimeInfo.app.ports[9999]}/"
		envProperties.each { k, v -> systemProperty (k, (v as String)) }
	}
}

dockerCompose.isRequiredBy(functionalTest)
